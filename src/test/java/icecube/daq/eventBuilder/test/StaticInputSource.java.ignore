package icecube.daq.eventBuilder.test;

import icecube.daq.common.DAQCmdInterface;

import icecube.daq.eventBuilder.monitoring.MonitoringData;

import icecube.daq.eventbuilder.IEventPayload;
import icecube.daq.eventbuilder.IReadoutDataPayload;

import icecube.daq.payload.ISourceID;
import icecube.daq.payload.IUTCTime;
import icecube.daq.payload.SourceIdRegistry;

import icecube.daq.payload.splicer.Payload;

import icecube.daq.sim.GenericHit;
import icecube.daq.sim.GenericReadoutElement;
import icecube.daq.sim.GenericTriggerRequest;
import icecube.daq.sim.HitGenerator;
import icecube.daq.sim.HitDataGenerator;
import icecube.daq.sim.IGenerator;
import icecube.daq.sim.TriggerRequestGenerator;

import icecube.daq.testUtil.InputSource;
import icecube.daq.testUtil.OutputDestination;

import icecube.daq.trigger.IHitPayload;
import icecube.daq.trigger.IReadoutRequest;
import icecube.daq.trigger.IReadoutRequestElement;
import icecube.daq.trigger.ITriggerRequestPayload;

import icecube.daq.trigger.impl.ReadoutRequestPayloadFactory;

import java.io.IOException;

import java.nio.ByteBuffer;

import java.nio.channels.Pipe;
import java.nio.channels.ReadableByteChannel;
import java.nio.channels.SelectableChannel;
import java.nio.channels.SelectionKey;
import java.nio.channels.Selector;

import java.util.ArrayList;
import java.util.Collection;
import java.util.Collections;
import java.util.Comparator;
import java.util.Iterator;
import java.util.List;

import org.apache.commons.logging.Log;
import org.apache.commons.logging.LogFactory;

class BaseSorter
{
    public boolean equals(Object obj)
    {
        if (obj == null) {
            return false;
        }

        return getClass().equals(obj.getClass());
    }

    public int hashCode()
    {
        return getClass().hashCode();
    }
}

class EventHitSorter
    extends BaseSorter
    implements Comparator
{
    EventHitSorter()
    {
    }

    /**
     * Compare two hits by source ID and timestamp.
     */
    public int compare(Object o1, Object o2)
    {
        if (o1 == null) {
            if (o2 == null) {
                return 0;
            }

            return 1;
        } else if (o2 == null) {
            return -1;
        } else if (!(o1 instanceof IHitPayload)) {
            if (!(o2 instanceof IHitPayload)) {
                final String name1 = o1.getClass().getName();
                return name1.compareTo(o2.getClass().getName());
            }

            return 1;
        } else if (!(o2 instanceof IHitPayload)) {
            return -1;
        } else {
            return compare((IHitPayload) o1, (IHitPayload) o2);
        }
    }

    private int compare(IHitPayload h1, IHitPayload h2)
    {
        int cmp = compare(h1.getHitTimeUTC(), h2.getHitTimeUTC());
        if (cmp == 0) {
            cmp = compare(h1.getSourceID(), h2.getSourceID());
        }

        return cmp;
    }

    private int compare(ISourceID s1, ISourceID s2)
    {
        if (s1 == null) {
            if (s2 == null) {
                return 0;
            }

            return 1;
        } else if (s2 == null) {
            return -1;
        } else {
            return s1.getSourceID() - s2.getSourceID();
        }
    }

    private int compare(IUTCTime t1, IUTCTime t2)
    {
        if (t1 == null) {
            if (t2 == null) {
                return 0;
            }

            return 1;
        } else if (t2 == null) {
            return -1;
        } else {
            return (int) (t1.getUTCTimeAsLong() - t2.getUTCTimeAsLong());
        }
    }
}

class GenericHitSorter
    extends BaseSorter
    implements Comparator
{
    public int compare(Object o1, Object o2)
    {
        if (o1 == null) {
            if (o2 == null) {
                return 0;
            }

            return 1;
        } else if (o2 == null) {
            return -1;
        } else if (!(o1 instanceof GenericHit)) {
            if (!(o2 instanceof GenericHit)) {
                final String name1 = o1.getClass().getName();
                return name1.compareTo(o2.getClass().getName());
            }

            return 1;
        } else if (!(o2 instanceof GenericHit)) {
            return -1;
        } else {
            return compare((GenericHit) o1, (GenericHit) o2);
        }
    }

    private int compare(GenericHit h1, GenericHit h2)
    {
        int cmp = (int) (h1.getTimeStamp() - h2.getTimeStamp());
        if (cmp == 0) {
            cmp = h1.getSourceId() - h2.getSourceId();
            if (cmp == 0) {
                cmp = (int) (h1.getDomId() - h2.getDomId());
            }
        }

        return cmp;
    }
}

class StringProcData
{
    private int srcId;
    private long firstDom;
    private int numDoms;

    StringProcData(long firstDom, int numDoms)
    {
        this.firstDom = firstDom;
        this.numDoms = numDoms;
    }

    int getSourceId()
    {
        return srcId;
    }

    boolean isDOMId(GenericHit hit)
    {
        return isDOMId(hit.getDomId());
    }

    boolean isDOMId(long domId)
    {
        return (domId >= firstDom && domId < firstDom + numDoms);
    }

    boolean isSourceId(GenericHit hit)
    {
        return isSourceId(hit.getSourceId());
    }

    boolean isSourceId(int srcId)
    {
        return srcId == this.srcId;
    }

    boolean isSourceString(GenericHit hit)
    {
        return (isSourceId(hit.getSourceId()) && isDOMId(hit.getDomId()));
    }

    void setSourceId(ISourceID srcId)
    {
        this.srcId = srcId.getSourceID();
    }

    public String toString()
    {
        return "[" + firstDom + "-" + (firstDom + numDoms - 1) + "]";
    }
}

public class StaticInputSource
    implements InputSource
{
    private static final Log log =
        LogFactory.getLog(StaticInputSource.class);

    private static final int READOUT_TYPE_IIIT_GLOBAL =
        IReadoutRequestElement.READOUT_TYPE_IIIT_GLOBAL;
    private static final int READOUT_TYPE_IT_GLOBAL =
        IReadoutRequestElement.READOUT_TYPE_IT_GLOBAL;
    private static final int READOUT_TYPE_II_GLOBAL =
        IReadoutRequestElement.READOUT_TYPE_II_GLOBAL;
    private static final int READOUT_TYPE_II_STRING =
        IReadoutRequestElement.READOUT_TYPE_II_STRING;
    private static final int READOUT_TYPE_II_MODULE =
        IReadoutRequestElement.READOUT_TYPE_II_MODULE;
    private static final int READOUT_TYPE_IT_MODULE =
        IReadoutRequestElement.READOUT_TYPE_IT_MODULE;

    private static final EventHitSorter evtHitSorter = new EventHitSorter();

    private static final GenericHitSorter genHitSorter =
        new GenericHitSorter();

    private Pipe.SourceChannel trigReqSrcChan;
    private Pipe.SinkChannel trigReqSinkChan;

    private Pipe.SourceChannel[] rdoutReqSrcChan;
    private Pipe.SinkChannel[] rdoutReqSinkChan;

    private Pipe.SourceChannel[] hitSrcChan;
    private Pipe.SinkChannel[] hitSinkChan;

    private boolean isTRRunning;
    private boolean isHitRunning;
    private boolean hasRun;

    private TriggerRequestGenerator trigReqGen = new TriggerRequestGenerator();
    private IGenerator hitGen;

    private ArrayList stringProcs = new ArrayList();

    private ArrayList trigReqList = new ArrayList();
    private ArrayList hitList = new ArrayList();

    private int nextTrigReqUID = 1;

    private int lagCount;

    private int runNumber;

    /**
     * Create a StaticInputSource
     */
    public StaticInputSource()
        throws IOException
    {
    }

    public void addHit(long timeStamp, long domId)
        throws IllegalArgumentException
    {
        addHit(timeStamp, domId, 1);
    }

    public void addHit(long timeStamp, long domId, int triggerMode)
        throws IllegalArgumentException
    {
        addHit(timeStamp, getSourceId(domId), domId, triggerMode);
    }

    public void addHit(long timeStamp, int srcId, long domId, int triggerMode)
        throws IllegalArgumentException
    {
        addHit(new GenericHit(timeStamp, domId, srcId, triggerMode));
    }

    public void addHit(GenericHit hit)
        throws IllegalArgumentException
    {
        if (hitList.size() > 0) {
            GenericHit oldHit =
                (GenericHit) hitList.get(hitList.size() - 1);

            if (hit.getTimeStamp() < oldHit.getTimeStamp()) {
                final String errMsg = "Hit time " + hit.getTimeStamp() +
                    " is before previous hit time " + oldHit.getTimeStamp();

                throw new IllegalArgumentException(errMsg);
            }
        }

        hitList.add(hit);
    }

    /**
     * Add a string processor with sequentially numbered DOMs.
     *
     * @param firstDom first DOM ID
     * @param numDoms total number of DOMs in string
     */
    public void addStringProcessor(long firstDom, int numDoms)
    {
        final long lastDom = firstDom + numDoms - 1;

        Iterator spIter = stringProcs.iterator();
        while (spIter.hasNext()) {
            StringProcData spData = (StringProcData) spIter.next();
            if (spData.isDOMId(firstDom) || spData.isDOMId(lastDom)) {
                throw new Error("New string processor [" + firstDom + "-" +
                                lastDom + "] overlaps " + spData);
            }
        }

        stringProcs.add(new StringProcData(firstDom, numDoms));
    }

    public void addTriggerRequest(ArrayList rdOutList)
        throws IllegalArgumentException
    {
        addTriggerRequest(1, 0, rdOutList);
    }

    public void addTriggerRequest(int type, int configId, ArrayList rdOutList)
        throws IllegalArgumentException
    {
        GenericTriggerRequest trigReq = new GenericTriggerRequest();
        trigReq.setTriggerUID(nextTrigReqUID++);
        trigReq.setTriggerType(type);
        trigReq.setTriggerConfigId(configId);
        trigReq.setSourceId(SourceIdRegistry.GLOBAL_TRIGGER_SOURCE_ID);

        long firstTime = Long.MAX_VALUE;
        long lastTime = Long.MIN_VALUE;

        Iterator iter = rdOutList.iterator();
        while (iter.hasNext()) {
            GenericReadoutElement rdOut = (GenericReadoutElement) iter.next();

            final int rSrcId = rdOut.getSourceId();
            final int rDomId = rdOut.getDomId();

            switch (rdOut.getReadoutType()) {
            case READOUT_TYPE_IIIT_GLOBAL:
                if (rSrcId != -1) {
                    throw new Error("Bad source ID " + rSrcId +
                                    " in IIIT_GLOBAL request");
                } else if (rDomId != -1) {
                    throw new Error("Bad DOM ID " + rDomId +
                                    " in IIIT_GLOBAL request");
                }
                break;
            case READOUT_TYPE_IT_GLOBAL:
                if (rSrcId != -1) {
                    throw new Error("Bad source ID " + rSrcId +
                                    " in IT_GLOBAL request");
                } else if (rDomId != -1) {
                    throw new Error("Bad DOM ID " + rDomId +
                                    " in IT_GLOBAL request");
                }
                break;
            case READOUT_TYPE_II_GLOBAL:
                if (rSrcId != -1) {
                    throw new Error("Bad source ID " + rSrcId +
                                    " in II_GLOBAL request");
                } else if (rDomId != -1) {
                    throw new Error("Bad DOM ID " + rDomId +
                                    " in II_GLOBAL request");
                }
                break;
            case READOUT_TYPE_II_STRING:
                throw new Error("II_STRING unimplemented");
            case READOUT_TYPE_II_MODULE:
                throw new Error("II_MODULE unimplemented");
            case READOUT_TYPE_IT_MODULE:
                throw new Error("IT_MODULE unimplemented");
            default:
                throw new Error("Unknown readout request type#" +
                                rdOut.getReadoutType());
            }

            if (rdOut.getFirstTime() < firstTime) {
                firstTime = rdOut.getFirstTime();
            }
            if (rdOut.getLastTime() > lastTime) {
                lastTime = rdOut.getLastTime();
            }

            trigReq.addReadoutElement(rdOut);
        }

        trigReq.setFirstTime(firstTime);
        trigReq.setLastTime(lastTime);

        addTriggerRequest(trigReq);
    }

    public void addTriggerRequest(GenericTriggerRequest trigReq)
        throws IllegalArgumentException
    {
        if (trigReqList.size() > 0) {
            GenericTriggerRequest oldReq =
                (GenericTriggerRequest) trigReqList.get(trigReqList.size() - 1);

            if (trigReq.getFirstTime() <= oldReq.getLastTime()) {
                final String errMsg =
                    "Trigger request start time " + trigReq.getFirstTime() +
                    " is before or at end of previous trigger time " +
                    oldReq.getLastTime();

                throw new IllegalArgumentException(errMsg);
            }
        }

        trigReqList.add(trigReq);
    }

    public void configure()
        throws IOException
    {
        if (trigReqSrcChan != null || rdoutReqSinkChan != null ||
            hitSrcChan != null)
        {
            throw new Error("StaticInputSource has already been configured");
        }

        final int numSrcs = stringProcs.size();
        if (numSrcs == 0) {
            throw new Error("No string processors configured");
        }

        hitSrcChan = new Pipe.SourceChannel[numSrcs];
        hitSinkChan = new Pipe.SinkChannel[numSrcs];
        for (int i = 0; i < numSrcs; i++) {
            Pipe hitPipe = Pipe.open();
            hitSinkChan[i] = hitPipe.sink();
            hitSinkChan[i].configureBlocking(true);

            hitSrcChan[i] = hitPipe.source();
            hitSrcChan[i].configureBlocking(false);
        }

        rdoutReqSrcChan = new Pipe.SourceChannel[numSrcs];
        rdoutReqSinkChan = new Pipe.SinkChannel[numSrcs];
        for (int i = 0; i < numSrcs; i++) {
            Pipe rdoutReqPipe = Pipe.open();
            rdoutReqSinkChan[i] = rdoutReqPipe.sink();
            rdoutReqSinkChan[i].configureBlocking(false);

            rdoutReqSrcChan[i] = rdoutReqPipe.source();
            rdoutReqSrcChan[i].configureBlocking(true);
        }

        Pipe trPipe = Pipe.open();
        trigReqSinkChan = trPipe.sink();
        trigReqSrcChan = trPipe.source();
        trigReqSinkChan.configureBlocking(true);
        trigReqSrcChan.configureBlocking(false);
    }

    private static final List extractHits(IEventPayload evt)
    {
        List rdList = evt.getReadoutDataPayloads();
        if (rdList == null) {
            return null;
        }

        ArrayList list = new ArrayList();

        for (int i = 0; i < rdList.size(); i++) {
            IReadoutDataPayload rdp = (IReadoutDataPayload) rdList.get(i);
            try {
                ((Payload) rdp).loadPayload();
            } catch (Exception ex) {
                throw new Error("Couldn't load ReadoutData#" + i +
                                " for event #" + evt.getEventUID(), ex);
            }
            list.addAll(rdp.getDataPayloads());
        }

        Collections.sort(list, evtHitSorter);
        return list;
    }

    /**
     * Generate a RuntimeException with the specified error message.
     *
     * @param errMsg error message
     */
    private static final void fail(String errMsg)
    {
        throw new RuntimeException(errMsg);
    }

    /**
     * Generate a RuntimeException with the specified error message.
     *
     * @param errMsg error message
     * @param thr Throwable object
     */
    private static final void fail(String errMsg, Throwable thr)
    {
        throw new RuntimeException(errMsg, thr);
    }

    /**
     * Generate default engineering format hits.
     */
    public void generateEngFmtHits()
    {
        hitGen = new HitDataGenerator();
    }

    /**
     * Generate engineering format hits.
     *
     * @param nFadc number of fadc samples
     * @param atwd01 atwd format for channels 0 and 1
     * @param atwd23 atwd format for channels 2 and 3
     */
    public void generateEngFmtHits(int nFadc, int atwd01, int atwd23)
    {
        hitGen = new HitDataGenerator(nFadc, atwd01, atwd23);
    }

    /**
     * Generate simple hits.
     */
    public void generateSimpleHits()
    {
        hitGen = new HitGenerator();
    }

    /**
     * Return an array of hit sources.
     *
     * @return hit sources
     */
    public InputSource[] getHitSources()
        throws IOException
    {
        if (hitSrcChan == null) {
            configure();
        }

        InputSource[] srcs = new InputSource[hitSinkChan.length];
        for (int i = 0; i < hitSinkChan.length; i++) {
            srcs[i] = new InputSourceWrapper(this, hitSrcChan[i],
                                             hitSinkChan[i]);
        }
        return srcs;
    }

    /**
     * Unimplemented.
     *
     * @return ???
     */
    public int getNumDoms()
    {
        throw new Error("Unimplemented");
    }

    /**
     * Unimplemented.
     *
     * @return ???
     */
    public long getNumOfHits()
    {
        throw new Error("Unimplemented");
    }

    /**
     * Get number of string processors being simulated.
     *
     * @return number of string processors
     */
    public int getNumOfStringProcessors()
    {
        return stringProcs.size();
    }

    /**
     * Unimplemented.
     *
     * @return ???
     */
    public String getPayloadType()
    {
        throw new Error("Unimplemented");
    }

    /**
     * Unimplemented.
     *
     * @return ???
     */
    public int getProcessDuration()
    {
        throw new Error("Unimplemented");
    }

    /**
     * Unimplemented.
     *
     * @return ???
     */
    public double getRate()
    {
        throw new Error("Unimplemented");
    }

    /**
     * Return an array of readout request destinations.
     *
     * @return readout request destinations
     */
    public OutputDestination[] getReadoutRequestDestinations()
        throws IOException
    {
        if (rdoutReqSinkChan == null) {
            configure();
        }

        OutputDestination[] dests =
            new OutputDestination[rdoutReqSinkChan.length];
        for (int i = 0; i < rdoutReqSinkChan.length; i++) {
            dests[i] = new OutputDestinationWrapper(this, rdoutReqSinkChan[i]);
        }
        return dests;
    }

    /**
     * Unimplemented.
     *
     * @return ???
     */
    public SelectableChannel getSourceChannel()
    {
        throw new Error("Unimplemented");
    }

    /**
     * Unimplemented.
     *
     * @return ???
     */
    public int getSourceID()
    {
        throw new Error("Unimplemented");
    }

    /**
     * Find the source ID of the string containing the specified DOM.
     *
     * @param domId DOM ID
     *
     * @return source ID
     *
     * @throws IllegalArgumentException if the DOM ID was not valid
     */
    private int getSourceId(long domId)
        throws IllegalArgumentException
    {
        Iterator spIter = stringProcs.iterator();
        while (spIter.hasNext()) {
            StringProcData spData = (StringProcData) spIter.next();
            if (spData.isDOMId(domId)) {
                return spData.getSourceId();
            }
        }

        throw new IllegalArgumentException("DOM " + domId + " is not valid");
    }

    /**
     * Unimplemented.
     *
     * @return ???
     */
    public int getTriggerMode()
    {
        throw new Error("Unimplemented");
    }

    /**
     * Return the trigger request source channel.
     *
     * @return trigger request source channel
     */
    public InputSource getTriggerRequestSource()
        throws IOException
    {
        if (trigReqSrcChan == null) {
            configure();
        }

        return new InputSourceWrapper(this, trigReqSrcChan, trigReqSinkChan);
    }

    /**
     * Unimplemented.
     *
     * @return ???
     */
    public boolean isRunning()
    {
        throw new Error("Unimplemented");
    }

    private int listHits(GenericTriggerRequest trigReq, ArrayList hitList,
                         int hitIndex, ArrayList expHits)
    {
        final String INICE_NAME = DAQCmdInterface.DAQ_STRINGPROCESSOR;
        final String ICETOP_NAME = DAQCmdInterface.DAQ_ICETOP_DATA_HANDLER;
        final String ILLEGAL_NAME =
            DAQCmdInterface.DAQ_PAYLOAD_INVALID_SOURCE_ID;

        expHits.clear();

        while (hitIndex < hitList.size()) {
            GenericHit hit = (GenericHit) hitList.get(hitIndex);

            // if this hit is after the trigger request, we're done
            if (hit.getTimeStamp() > trigReq.getLastTime()) {
                break;
            }

            // we'll use this hit somehow
            hitIndex++;

            // skip hits before start of trigger request
            if (hit.getTimeStamp() < trigReq.getFirstTime()) {
                continue;
            }

            final int hitSrcId = hit.getSourceId();

            final String daqName =
                SourceIdRegistry.getDAQNameFromSourceID(hitSrcId);

            Iterator roIter = trigReq.getReadoutElementList().iterator();
            while (roIter.hasNext()) {
                GenericReadoutElement elem =
                    (GenericReadoutElement) roIter.next();
                if (hit.getTimeStamp() < elem.getFirstTime() ||
                    hit.getTimeStamp() > elem.getLastTime())
                {
                    continue;
                }

                boolean matched = false;
                switch (elem.getReadoutType()) {
                case IReadoutRequestElement.READOUT_TYPE_IIIT_GLOBAL:
                    matched = true;
                    break;
                case IReadoutRequestElement.READOUT_TYPE_II_GLOBAL:
                    if (daqName.equals(INICE_NAME) ||
                        daqName.equals(ILLEGAL_NAME))
                    {
                        matched = true;
                    }
                    break;
                case IReadoutRequestElement.READOUT_TYPE_IT_GLOBAL:
                    if (daqName.equals(ICETOP_NAME) ||
                        daqName.equals(ILLEGAL_NAME))
                    {
                        matched = true;
                    }
                    break;
                case IReadoutRequestElement.READOUT_TYPE_II_STRING:
                    if (hitSrcId == elem.getSourceId())
                    {
                        matched = true;
                    }
                    break;
                case IReadoutRequestElement.READOUT_TYPE_II_MODULE:
                    if (daqName.equals(INICE_NAME) &&
                        hit.getDomId() == elem.getDomId())
                    {
                        matched = true;
                    }
                    break;
                case IReadoutRequestElement.READOUT_TYPE_IT_MODULE:
                    if (daqName.equals(ICETOP_NAME) &&
                        hit.getDomId() == elem.getDomId())
                    {
                        matched = true;
                    }
                    break;
                }

                if (matched) {
                    expHits.add(hit);
                    break;
                }
            }
        }

        Collections.sort(expHits, genHitSorter);
        return hitIndex;
    }

    public void reset()
    {
        if (!isTRRunning && !isHitRunning) {
            hasRun = false;
        } else if (log.isWarnEnabled()) {
            log.warn("cannot reset while input source is running");
        }
    }

    private void sendHitPayload(GenericHit hit)
    {
        ByteBuffer buf = hitGen.generatePayload(hit);

        boolean sent = false;

        Iterator iter = stringProcs.iterator();
        for (int i = 0; iter.hasNext(); i++) {
            StringProcData sp = (StringProcData) iter.next();
            if (sp.isSourceString(hit)) {
                try {
                    sendPayload(buf, hitSinkChan[i]);
                    sent = true;
                } catch (IOException ioe) {
                    fail("While sending hit: ", ioe);
                }
            }
        }

        if (sent) {
            if (log.isDebugEnabled()) {
                log.debug("Sent HitPayload with timestamp " +
                          hit.getTimeStamp());
            }
        } else {
            if (log.isDebugEnabled()) {
                log.debug("Didn't send HitPayload with timestamp " +
                          hit.getTimeStamp());
            }
        }
    }

    private void sendPayload(ByteBuffer buf, Pipe.SinkChannel sinkChan)
        throws IOException
    {
        buf.clear();

        int len = buf.getInt(0);
        buf.limit(len);
        buf.position(0);
        if (buf.getInt(0) < 4) {
            throw new IOException("Bad payload length " + len);
        }

        int result = sinkChan.write(buf);
        if (result != len) {
            throw new IOException("SinkChannel write failed, expected " +
                                  len + " bytes, but wrote " + result);
        }
    }

    private void sendTriggerRequestPayload(GenericTriggerRequest trigReq)
    {
        try {
            sendPayload(trigReqGen.generatePayload(trigReq), trigReqSinkChan);
        } catch (IOException ioe) {
            fail("While sending trigger request: ", ioe);
        }

        if (log.isDebugEnabled()) {
            log.debug("Sent TriggerRequestPayload with" +
                      " UID " + trigReq.getTriggerUID() +
                      " timestamp " + trigReq.getTimeStamp());
        }
    }

    public void sendHitStopSignal()
        throws IOException
    {
        final int doneLen = 4;

        ByteBuffer buf = ByteBuffer.allocate(doneLen);
        buf.clear();
        buf.limit(doneLen);
        buf.putInt(0, doneLen);

        for (int i = 0; i < hitSinkChan.length; i++) {
            buf.position(0);
            hitSinkChan[i].write(buf);
        }

        if (log.isInfoEnabled()) {
            log.info(toString() + " --- Sent hit stop");
        }

        isHitRunning = false;
    }

    public void sendTriggerRequestStopSignal()
        throws IOException
    {
        final int doneLen = 4;

        ByteBuffer buf = ByteBuffer.allocate(doneLen);
        buf.clear();
        buf.limit(doneLen);
        buf.putInt(0, doneLen);

        buf.position(0);
        trigReqSinkChan.write(buf);

        if (log.isInfoEnabled()) {
            log.info(toString() + " --- Sent trigReq stop");
        }

        isTRRunning = false;
    }

    /**
     * Set number of hits which must be sent before the associated trigger
     * request is sent.  This is mainly useful in stress-testing the event
     * builder.
     *
     * For instance, assume there are 3 trigger requests and 15 hits for
     * each trigger request.  If the lag count is set to 20, then all 15 hits
     * from the first trigger request and 5 hits from the second trigger
     * request would be sent before the first trigger request was sent.  After
     * that, the remaining 10 hits from the second trigger request and the
     * first 5 hits from the third trigger request would be sent before the
     * second trigger request was be sent.  Finally, the last 10 hits would be
     * sent, followed by the final trigger request.
     *
     * If the lag count is set to 60, then all the hits would be sent,
     * followed by all the trigger requests.
     *
     * If the lag count is set to 0, then each trigger request will be sent,
     * followed by all the hits associated with that trigger request.
     *
     * @param lagCount number of hits to send before sending trigger request
     */
    public void setLagCount(int lagCount)
    {
        this.lagCount = lagCount;
    }

    /**
     * Unimplemented.
     *
     * @param i0 ???
     */
    public void setNumDoms(int i0)
    {
        throw new Error("Unimplemented");
    }

    /**
     * Unimplemented.
     *
     * @param x0 ???
     */
    public void setNumOfHits(long x0)
    {
        throw new Error("Unimplemented");
    }

    /**
     * Unimplemented.
     *
     * @param s0 ???
     */
    public void setPayloadType(String s0)
    {
        throw new Error("Unimplemented");
    }

    /**
     * Unimplemented.
     *
     * @param i0 ???
     */
    public void setProcessDuration(int i0)
    {
        throw new Error("Unimplemented");
    }

    /**
     * Unimplemented.
     *
     * @param x0 ???
     */
    public void setRate(double x0)
    {
        throw new Error("Unimplemented");
    }

    /**
     * Set DAQ run number.
     *
     * @param runNumber run number
     */
    public void setRunNumber(int runNumber)
    {
        this.runNumber = runNumber;
    }

    /**
     * Unimplemented.
     *
     * @param i0 ???
     */
    public void setSourceID(int i0)
    {
        throw new Error("Unimplemented");
    }

    public void setTargetSourceIds(Collection coll)
    {
        if (coll.size() != stringProcs.size()) {
            throw new Error("Expected " + stringProcs.size() +
                            " string processors, but " + coll.size() +
                            " have been configured");
        }

        Iterator iter = coll.iterator();
        for (int i = 0; iter.hasNext(); i++) {
            ISourceID srcId = (ISourceID) iter.next();
            ((StringProcData) stringProcs.get(i)).setSourceId(srcId);
        }
    }

    /**
     * Unimplemented.
     *
     * @param i0 ???
     */
    public void setTriggerMode(int i0)
    {
        throw new Error("Unimplemented");
    }

    /**
     * Start writing data.
     *
     * @throws IOException
     */
    public void startProcessing()
        throws IOException
    {
        if (!isTRRunning && !isHitRunning && !hasRun) {
            if (hitSrcChan == null) {
                configure();
            }

            isTRRunning = true;
            isHitRunning = true;

            Thread inThread = new Thread(new InputSender(lagCount));
            inThread.setName("InputSender");
            inThread.start();

            Thread outThread = new Thread(new RequestReceiver());
            outThread.setName("RequestReceiver");
            outThread.start();

            hasRun = true;

            if (log.isInfoEnabled()) {
                log.info("starting " + toString());
            }
        }
    }

    /**
     * Stop processing data.
     *
     * @throws IOException
     */
    public void stopProcessing()
        throws IOException
    {
        if (isTRRunning || isHitRunning) {
            isTRRunning = false;
            isHitRunning = false;

            if (log.isInfoEnabled()) {
                log.info("Stopping processing " + toString());
            }
        }
    }

    /**
     * Validate the final list of EventPauload_v2 objects.
     * Throws a <code>RuntimeException</code> if there is a problem with an
     * event.
     */
    public void validateEvents(Iterator events)
    {
        int hitIndex = 0;
        ArrayList expHits = new ArrayList();

        Iterator trIter = trigReqList.iterator();
        while (trIter.hasNext()) {
            GenericTriggerRequest trigReq =
                (GenericTriggerRequest) trIter.next();

            hitIndex = listHits(trigReq, hitList, hitIndex, expHits);
            if (hitList == null || hitList.size() == 0) {
                continue;
            }

            if (!events.hasNext()) {
                fail("Ran out of events");
            }

            IEventPayload evt = (IEventPayload) events.next();
            if (evt.getRunNumber() != runNumber) {
                fail("For event #" + evt.getEventUID() +
                     ", expected run number " + runNumber +
                     " but got " + evt.getRunNumber());
            }

            validateEventTriggerRequest(evt, trigReq);

            validateEventHits(evt, expHits);
        }

        int extra = 0;
        while (events.hasNext()) {
            Payload evt = (Payload) events.next();
            extra++;
        }

        if (extra > 0) {
            fail(Integer.toString(extra) +
                 " unexpected events were generated");
        }
    }

    private void validateEventHits(IEventPayload evt, ArrayList expHits)
    {
        List evtHits = evt.getHitList();
        if (evtHits == null) {
            evtHits = extractHits(evt);
        }

        if (evtHits == null || evtHits.size() != expHits.size()) {
            fail("Expected " + expHits.size() + " hits for event #" +
                 evt.getEventUID() + ", not " +
                 (evtHits == null ? "null" :
                  Integer.toString(evtHits.size())));
        }

        for (int i = 0; i < expHits.size(); i++) {
            GenericHit expHit = (GenericHit) expHits.get(i);
            IHitPayload actHit = (IHitPayload) evtHits.get(i);

            if (expHit.getTimeStamp() !=
                actHit.getHitTimeUTC().getUTCTimeAsLong())
            {
                fail("For hit #" + i + " from event #" + evt.getEventUID() +
                     ", expected time " + expHit.getTimeStamp() + ", got " +
                     actHit.getHitTimeUTC().getUTCTimeAsLong());
            }

            if (expHit.getDomId() != actHit.getDOMID().getDomIDAsLong()) {
                fail("For hit #" + i + " from event #" + evt.getEventUID() +
                     ", expected DOM " + expHit.getDomId() + ", got " +
                     actHit.getDOMID().getDomIDAsLong());
            }

            if (expHit.getSourceId() !=
                actHit.getSourceID().getSourceID())
            {
                fail("For hit #" + i + " from event #" + evt.getEventUID() +
                     ", expected Source " + expHit.getSourceId() + ", got " +
                     actHit.getSourceID().getSourceID());
            }
        }
    }

    private void validateEventTriggerRequest(IEventPayload evt,
                                             GenericTriggerRequest expTrigReq)
    {
        if (evt.getFirstTimeUTC().getUTCTimeAsLong() !=
            expTrigReq.getFirstTime())
        {
            fail("Event #" + evt.getEventUID() + " first time " +
                 evt.getFirstTimeUTC().getUTCTimeAsLong() +
                 "a does match trigger request first time " +
                 expTrigReq.getFirstTime());
        }
        if (evt.getLastTimeUTC().getUTCTimeAsLong() !=
            expTrigReq.getLastTime())
        {
            fail("Event #" + evt.getEventUID() + " last time " +
                 evt.getLastTimeUTC().getUTCTimeAsLong() +
                 " does match trigger request last time " +
                 expTrigReq.getLastTime());
        }

        ITriggerRequestPayload trigReq = evt.getTriggerRequestPayload();
        if (trigReq.getFirstTimeUTC().getUTCTimeAsLong() !=
            expTrigReq.getFirstTime())
        {
            fail("Event #" + evt.getEventUID() +
                 " trigger request first time " +
                 trigReq.getFirstTimeUTC().getUTCTimeAsLong() +
                 " does match expected first time " +
                 expTrigReq.getFirstTime());
        }
        if (trigReq.getLastTimeUTC().getUTCTimeAsLong() !=
            expTrigReq.getLastTime())
        {
            fail("Event #" + evt.getEventUID() +
                 " trigger request last time " +
                 trigReq.getLastTimeUTC().getUTCTimeAsLong() +
                 " does match expected last time " + expTrigReq.getLastTime());
        }
        if (trigReq.getTriggerType() != expTrigReq.getTriggerType()) {
            fail("Event #" + evt.getEventUID() +
                 " trigger request type " + trigReq.getTriggerType() +
                 " does match expected type " + expTrigReq.getTriggerType());
        }
        if (trigReq.getTriggerConfigID() != expTrigReq.getTriggerConfigId()) {
            fail("Event #" + evt.getEventUID() +
                 " trigger request config ID " + trigReq.getTriggerConfigID() +
                 " does match expected config ID " +
                 expTrigReq.getTriggerConfigId());
        }
        if (trigReq.getSourceID().getSourceID() != expTrigReq.getSourceId()) {
            fail("Event #" + evt.getEventUID() +
                 " trigger request source ID " +
                 trigReq.getSourceID().getSourceID() +
                 " does match expected source ID " + expTrigReq.getSourceId());
        }
    }

    /**
     * Validate the final monitoring data for a single run.
     *
     * Throws a <code>RuntimeException</code> if any problem is found.
     *
     * @param monData monitoring data
     */
    public void validateMonitoringData(MonitoringData monData)
    {
        validateMonitoringData(monData, 1);
    }

    /**
     * Validate the final monitoring data.
     *
     * Throws a <code>RuntimeException</code> if any problem is found.
     *
     * @param monData monitoring data
     * @param numRuns number of runs
     */
    public void validateMonitoringData(MonitoringData monData, int numRuns)
    {
        final int GLOBAL_TRIG_STOP_MULTIPLIER = 1;

        // make sure nothing is stuck in the system
        if (monData.getNumTriggerRequestsQueued() != 0) {
            fail("Didn't expect " + monData.getNumTriggerRequestsQueued() +
                 " queued trigger requests");
        }
        if (monData.getNumReadoutsCached() != 0) {
            fail("Didn't expect " + monData.getNumReadoutsCached() +
                 " cached hits");
        }
        if (monData.getNumReadoutsCached() != 0) {
            fail("Didn't expect " + monData.getNumReadoutsCached() +
                 " cached hits");
        }
        if (monData.getNumReadoutsQueued() != 0) {
            fail("Didn't expect " + monData.getNumReadoutsQueued() +
                 " queued hits");
        }

        // make sure nothing failed
        if (monData.getTotalEventsFailed() != 0) {
            fail("Didn't expect " + monData.getTotalEventsFailed() +
                 " failed events");
        }
        if (monData.getTotalBadReadouts() != 0) {
            fail("Didn't expect " + monData.getTotalBadReadouts() +
                 " bad hits");
        }
        if (monData.getNumNullReadouts() != 0) {
            fail("Didn't expect " + monData.getNumNullReadouts() +
                 " null hits");
        }
        if (monData.getNumNullEvents() != 0) {
            fail("Didn't expect " + monData.getNumNullEvents() +
                 " null events");
        }

        // check that some per-run values balance
        if (monData.getNumReadoutsReceived() != monData.getNumRecycled()) {
            fail("Num hits received (" + monData.getNumReadoutsReceived() +
                 ") does not match num hits recycled (" +
                 monData.getNumRecycled() + ")");
        }

        // make sure totals and per-run values match
        if ((monData.getNumEventsSent() * numRuns) !=
            monData.getTotalEventsSent())
        {
            fail("Total events sent (" + monData.getTotalEventsSent() +
                 ") does not match per-run value (" +
                 (monData.getNumEventsSent() * numRuns) + ")");
        }
        if ((monData.getNumReadoutsDiscarded() * numRuns) !=
            monData.getTotalReadoutsDiscarded())
        {
            fail("Total hits discarded (" +
                 monData.getTotalReadoutsDiscarded() +
                 ") does not match per-run value (" +
                 (monData.getNumReadoutsDiscarded() * numRuns) + ")");
        }
        if ((monData.getNumReadoutsReceived() * numRuns) !=
            monData.getTotalReadoutsReceived())
        {
            fail("Total hits received (" + monData.getTotalReadoutsReceived() +
                 ") does not match per-run value (" +
                 (monData.getNumReadoutsReceived() * numRuns) + ")");
        }
        if ((monData.getNumTriggerRequestsReceived() * numRuns) !=
            monData.getTotalTriggerRequestsReceived())
        {
            fail("Total trigger requests received (" +
                 monData.getTotalTriggerRequestsReceived() +
                 ") does not match per-run value (" +
                 monData.getNumTriggerRequestsReceived() + ")");
        }

        // number of events should match number of trigger requests
        if ((monData.getTotalTriggerRequestsReceived() -
             monData.getNumTriggerRequestsDropped()) !=
            monData.getTotalEventsSent())
        {
            fail("Number of trigger requests received (" +
                 monData.getTotalTriggerRequestsReceived() +
                 ") minus number dropped (" +
                 monData.getNumTriggerRequestsDropped() +
                 ") does not match number of events sent (" +
                 monData.getTotalEventsSent() + ")");
        }

        // check number of trigger requests and hits
        if (monData.getTotalTriggerRequestsReceived() !=
            (trigReqList.size() * numRuns))
        {
            fail("Received " +
                 monData.getTotalTriggerRequestsReceived() +
                 " trigger requests, not " + (trigReqList.size() * numRuns));
        }
        if (monData.getTotalReadoutsReceived() != (hitList.size() * numRuns)) {
            fail("Received " + monData.getTotalReadoutsReceived() +
                 " hits, not " + (hitList.size() * numRuns));
        }

        // make sure number of stop messages is internally consistent
        if (monData.getTotalGlobalTrigStopsReceived() !=
            (monData.getTotalStopsSent() * GLOBAL_TRIG_STOP_MULTIPLIER))
        {
            fail("Received " + monData.getTotalGlobalTrigStopsReceived() +
                 " stop msgs, but sent " + monData.getTotalStopsSent());
        }
        if (monData.getTotalStopsSent() !=
            monData.getTotalSplicerStopsReceived())
        {
            fail("Sent " + monData.getTotalStopsSent() +
                 " stop msgs, but back end received " +
                 monData.getTotalSplicerStopsReceived());
        }

        // make sure expected number of stop messages were received
        if (monData.getTotalGlobalTrigStopsReceived() !=
            (numRuns * GLOBAL_TRIG_STOP_MULTIPLIER))
        {
            fail("Expected " + (numRuns * GLOBAL_TRIG_STOP_MULTIPLIER) +
                 " stop msgs, received " +
                 monData.getTotalGlobalTrigStopsReceived());
        }
    }

    /**
     * Write trigger request and hit payloads to appropriate channels.
     */
    class InputSender
        implements Runnable
    {
        private int lagCount;

        InputSender(int lagCount)
        {
            this.lagCount = lagCount;
        }

        public void run()
        {
            sendPayloads();

            try {
                sendTriggerRequestStopSignal();
            } catch (IOException ioe) {
                fail("Could not sent trigger request stop signal", ioe);
            }
        }

        private void sendPayloads()
        {
            int hitIndex = 0;

            if (hitGen == null) {
                hitGen = new HitGenerator();
            }

            Iterator trIter = trigReqList.iterator();
            while (isTRRunning && trIter.hasNext()) {
                GenericTriggerRequest curTrigReq =
                    (GenericTriggerRequest) trIter.next();
                LaggedTriggerRequest.add(curTrigReq, hitIndex);

                while (isHitRunning && hitIndex < hitList.size()) {
                    GenericHit hit = (GenericHit) hitList.get(hitIndex);
                    if (hit.getTimeStamp() >= curTrigReq.getFirstTime()) {
                        // if this hit is after the trigger request,
                        //   break out and get another trigger request
                        if (hit.getTimeStamp() > curTrigReq.getLastTime()) {
                            break;
                        }
                    }

                    // if it's time, send lagged trigger request
                    if (LaggedTriggerRequest.isSendable(hitIndex, lagCount)) {
                        GenericTriggerRequest trigReq =
                            LaggedTriggerRequest.getTriggerRequest();
                        sendTriggerRequestPayload(trigReq);
                    }

                    sendHitPayload(hit);
                    hitIndex++;
                }

                // let event builder run for a bit
                Thread.yield();
            }

            // flush remaining hits
            for ( ; isHitRunning && hitIndex < hitList.size(); hitIndex++) {
                GenericHit hit = (GenericHit) hitList.get(hitIndex);

                // if it's time, send lagged trigger request
                if (LaggedTriggerRequest.isSendable(hitIndex, lagCount)) {
                    GenericTriggerRequest trigReq =
                        LaggedTriggerRequest.getTriggerRequest();
                    sendTriggerRequestPayload(trigReq);
                }

                sendHitPayload(hit);
            }

            // flush remaining trigger requests
            while (true) {
                GenericTriggerRequest trigReq =
                    LaggedTriggerRequest.getTriggerRequest();
                if (trigReq == null) {
                    break;
                }

                sendTriggerRequestPayload(trigReq);
            }
        }
    }

    class InputSourceWrapper
        implements InputSource
    {
        private StaticInputSource evtSrc;
        private SelectableChannel srcChan;
        private SelectableChannel sinkChan;

        InputSourceWrapper(StaticInputSource evtSrc,
                           SelectableChannel srcChan,
                           SelectableChannel sinkChan)
        {
            this.evtSrc = evtSrc;
            this.srcChan = srcChan;
            this.sinkChan = sinkChan;
        }

        public int getNumDoms() { return evtSrc.getNumDoms(); }
        public long getNumOfHits() { return evtSrc.getNumOfHits(); }
        public String getPayloadType() { return evtSrc.getPayloadType(); }
        public int getProcessDuration() { return evtSrc.getProcessDuration(); }
        public double getRate() { return evtSrc.getRate(); }

        /**
         * Return the appropriate source channel.
         *
         * @return appropriate source channel
         */
        public SelectableChannel getSourceChannel()
        {
            return srcChan;
        }

        public int getSourceID() { return evtSrc.getSourceID(); }
        public int getTriggerMode() { return evtSrc.getTriggerMode(); }

        public boolean isRunning() { return isTRRunning; }

        public void setNumDoms(int xxx)
        {
            throw new RuntimeException("Please use " +
                                       evtSrc.getClass().getName() +
                                       " to set attributes");
        }

        public void setNumOfHits(long xxx)
        {
            throw new RuntimeException("Please use " +
                                       evtSrc.getClass().getName() +
                                       " to set attributes");
        }

        public void setPayloadType(String xxx)
        {
            throw new RuntimeException("Please use " +
                                       evtSrc.getClass().getName() +
                                       " to set attributes");
        }

        public void setProcessDuration(int xxx)
        {
            throw new RuntimeException("Please use " +
                                       evtSrc.getClass().getName() +
                                       " to set attributes");
        }

        public void setRate(double xxx)
        {
            throw new RuntimeException("Please use " +
                                       evtSrc.getClass().getName() +
                                       " to set attributes");
        }

        public void setSourceID(int xxx)
        {
            throw new RuntimeException("Please use " +
                                       evtSrc.getClass().getName() +
                                       " to set attributes");
        }

        public void setTriggerMode(int xxx)
        {
            throw new RuntimeException("Please use " +
                                       evtSrc.getClass().getName() +
                                       " to set attributes");
        }

        public void startProcessing()
            throws IOException
        {
            evtSrc.startProcessing();
        }

        public void stopProcessing()
            throws IOException
        {
            evtSrc.stopProcessing();
        }
    }

    class OutputDestinationWrapper
        implements OutputDestination
    {
        private StaticInputSource evtSrc;
        private SelectableChannel sinkChan;

        OutputDestinationWrapper(StaticInputSource evtSrc,
                                 SelectableChannel sinkChan)
        {
            this.evtSrc = evtSrc;
            this.sinkChan = sinkChan;
        }

        public SelectableChannel getSinkChannel()
        {
            return sinkChan;
        }

        public int getSourceID() { return evtSrc.getSourceID(); }
        public boolean isRunning() { return isHitRunning; }

        public void startProcessing()
        {
            try {
                evtSrc.startProcessing();
            } catch (IOException ioe) {
                log.error("Couldn't stop processing", ioe);
            }
        }

        public void stopProcessing()
        {
            try {
                evtSrc.stopProcessing();
            } catch (IOException ioe) {
                log.error("Couldn't stop processing", ioe);
            }
        }
    }

    class ReadoutRequestChannel
        implements ReadableByteChannel
    {
        private Pipe.SourceChannel chan;
        private boolean stopped;
        private int trigReqIndex;

        ReadoutRequestChannel(Pipe.SourceChannel chan)
            throws IOException
        {
            this.chan = chan;

            chan.configureBlocking(false);
        }

        /**
         * ReadableByteChannel method
         *
         * @throws IOException if there's a channel problem
         */
        public void close()
            throws IOException
        {
            chan.close();
        }

        private String describe(GenericReadoutElement elem)
        {
            final String typeStr;
            switch (elem.getReadoutType()) {
            case IReadoutRequestElement.READOUT_TYPE_IIIT_GLOBAL:
                typeStr = "Global";
                break;
            case IReadoutRequestElement.READOUT_TYPE_II_GLOBAL:
                typeStr = "InIceGlobal";
                break;
            case IReadoutRequestElement.READOUT_TYPE_IT_GLOBAL:
                typeStr = "IceTopGlobal";
                break;
            case IReadoutRequestElement.READOUT_TYPE_II_STRING:
                typeStr = "InIceString";
                break;
            case IReadoutRequestElement.READOUT_TYPE_II_MODULE:
                typeStr = "InIceModule";
                break;
            case IReadoutRequestElement.READOUT_TYPE_IT_MODULE:
                typeStr = "IceTopModule";
                break;
            default:
                typeStr = "Unknown#" + elem.getReadoutType();
                break;
            }

            final String firstStr = Long.toString(elem.getFirstTime());
            final String lastStr = Long.toString(elem.getLastTime());
            final String domStr = (elem.getDomId() == 0xffffffffffffffffL ?
                                   "NONE" : Long.toString(elem.getDomId()));
            final String srcStr;
            final int srcId = elem.getSourceId();
            if (srcId == -1) {
                srcStr = "NONE";
            } else if (srcId >= SourceIdRegistry.AMANDA_TRIGGER_SOURCE_ID) {
                srcStr = "AmTrig#" +
                    (srcId - SourceIdRegistry.AMANDA_TRIGGER_SOURCE_ID);
            } else if (srcId >= SourceIdRegistry.MONITORBUILDER_SOURCE_ID) {
                srcStr = "MonBldr#" +
                    (srcId - SourceIdRegistry.MONITORBUILDER_SOURCE_ID);
            } else if (srcId >= SourceIdRegistry.TCALBUILDER_SOURCE_ID) {
                srcStr = "TrigBldr#" +
                    (srcId - SourceIdRegistry.TCALBUILDER_SOURCE_ID);
            } else if (srcId >= SourceIdRegistry.EVENTBUILDER_SOURCE_ID) {
                srcStr = "EvtBldr#" +
                    (srcId - SourceIdRegistry.EVENTBUILDER_SOURCE_ID);
            } else if (srcId >= SourceIdRegistry.GLOBAL_TRIGGER_SOURCE_ID) {
                srcStr = "GlblTrig#" +
                    (srcId - SourceIdRegistry.GLOBAL_TRIGGER_SOURCE_ID);
            } else if (srcId >= SourceIdRegistry.ICETOP_TRIGGER_SOURCE_ID) {
                srcStr = "ITTrig#" +
                    (srcId - SourceIdRegistry.ICETOP_TRIGGER_SOURCE_ID);
            } else if (srcId >= SourceIdRegistry.INICE_TRIGGER_SOURCE_ID) {
                srcStr = "IITrig#" +
                    (srcId - SourceIdRegistry.INICE_TRIGGER_SOURCE_ID);
            } else if (srcId >=
                       SourceIdRegistry.ICETOP_DATA_HANDLER_SOURCE_ID)
            {
                srcStr = "IceTopDH#" +
                    (srcId - SourceIdRegistry.ICETOP_DATA_HANDLER_SOURCE_ID);
            } else if (srcId >= SourceIdRegistry.STRINGPROCESSOR_SOURCE_ID) {
                srcStr = "StrProc#" +
                    (srcId - SourceIdRegistry.STRINGPROCESSOR_SOURCE_ID);
            } else if (srcId >= SourceIdRegistry.DOMHUB_SOURCE_ID) {
                srcStr = "DomHub#" +
                    (srcId - SourceIdRegistry.DOMHUB_SOURCE_ID);
            } else {
                srcStr = "BOGUS#" + srcId;
            }

            return typeStr + " src " + srcStr + " dom " + domStr +
                " [" + firstStr + "-" + lastStr + "]";

        }

        /**
         * ReadableByteChannel method
         *
         * @return <tt>true</tt> if channel is open
         */
        public boolean isOpen()
        {
            return chan.isOpen();
        }

        boolean isRunning()
        {
            return !stopped;
        }

        void processRequest(IReadoutRequest req)
        {
            final int ebSrcId = SourceIdRegistry.EVENTBUILDER_SOURCE_ID;
            if (req.getSourceID().getSourceID() != ebSrcId) {
                throw new Error("Expected source ID " + ebSrcId + ", not " +
                                req.getSourceID());
            }

            if (trigReqIndex > trigReqList.size()) {
                throw new Error("Only expected " + trigReqList.size() +
                                " readout requests");
            }

            GenericTriggerRequest target =
                (GenericTriggerRequest) trigReqList.get(trigReqIndex);
            if (req.getUID() != target.getTriggerUID()) {
                throw new Error("Expected UID " + target.getTriggerUID() +
                                ". not " + req.getUID());
            }

            List reqList = req.getReadoutRequestElements();
            if (reqList == null) {
                throw new Error("No elements specified for readout request #" +
                                req.getUID());
            }

            List expList = target.getReadoutElementList();
            if (expList == null) {
                throw new Error("Expected list of elements" +
                                " for readout request #" + req.getUID() +
                                " is null");
            }

            for (int i = 0; i < reqList.size(); i++) {
                IReadoutRequestElement reqElem =
                    (IReadoutRequestElement) reqList.get(i);
                GenericReadoutElement expElem =
                    (GenericReadoutElement) expList.get(i);

                // XXX need to verify that source ID matches expected ID?

                final String daqName =
                    SourceIdRegistry.getDAQNameFromISourceID
                    (reqElem.getSourceID());

                switch (reqElem.getReadoutType()) {
                case IReadoutRequestElement.READOUT_TYPE_IIIT_GLOBAL:
                    throw new Error("Got illegal GLOBAL readout request");
                case IReadoutRequestElement.READOUT_TYPE_II_GLOBAL:
                    throw new Error("Got illegal IN_ICE GLOBAL" +
                                    " readout request");
                case IReadoutRequestElement.READOUT_TYPE_IT_GLOBAL:
                    throw new Error("Got illegal ICETOP GLOBAL" +
                                    " readout request");
                case IReadoutRequestElement.READOUT_TYPE_II_STRING:
                    if (!daqName.equals(DAQCmdInterface.DAQ_STRINGPROCESSOR)) {
                        throw new Error("Got IN_ICE STRING readout request" +
                                        ", but DAQ name is " + daqName);
                    }
                    break;
                case IReadoutRequestElement.READOUT_TYPE_II_MODULE:
                    if (!daqName.equals(DAQCmdInterface.DAQ_STRINGPROCESSOR)) {
                        throw new Error("Got IN_ICE MODULE readout request" +
                                        ", but DAQ name is " + daqName);
                    }
                    break;
                case IReadoutRequestElement.READOUT_TYPE_IT_MODULE:
                    if (!daqName.equals(DAQCmdInterface.DAQ_ICETOP_DATA_HANDLER)) {
                        throw new Error("Got ICETOP MODULE readout request" +
                                        ", but DAQ name is " + daqName);
                    }
                    break;
                default:
                    throw new Error("Got UNKNOWN readout request (#" +
                                    reqElem.getReadoutType());
                }

                if (reqElem.getDomID().getDomIDAsLong() != expElem.getDomId()) {
                    throw new Error("Expected DOM ID " +
                                    expElem.getDomId() +
                                    " for readout request #" + req.getUID() +
                                    " element #" + i + ", got DOM ID " +
                                    reqElem.getDomID().getDomIDAsLong());
                }

                final long firstTime =
                    reqElem.getFirstTimeUTC().getUTCTimeAsLong();
                if (firstTime != expElem.getFirstTime()) {
                    throw new Error("Expected first time " +
                                    expElem.getFirstTime() +
                                    " for readout request #" + req.getUID() +
                                    " element #" + i + ", got first time " +
                                    firstTime);
                }

                final long lastTime =
                    reqElem.getLastTimeUTC().getUTCTimeAsLong();
                if (lastTime != expElem.getLastTime()) {
                    throw new Error("Expected last time " +
                                    expElem.getLastTime() +
                                    " for readout request #" + req.getUID() +
                                    " element #" + i + ", got last time " +
                                    lastTime);
                }
            }

            trigReqIndex++;
        }

        /**
         * ReadableByteChannel method
         *
         * @param buf byte buffer
         *
         * @return number of bytes read
         *
         * @throws IOException if there is a channel problem
         */
        public int read(ByteBuffer buf)
            throws IOException
        {
            return chan.read(buf);
        }

        void register(Selector selector)
            throws IOException
        {
            chan.register(selector, SelectionKey.OP_READ, this);
        }

        void setStopped()
        {
            if (trigReqIndex != trigReqList.size()) {
                throw new Error("Stopping before all trigger requests" +
                                " were read");
            }

            stopped = true;
        }
    }

    class RequestReceiver
        implements Runnable
    {
        private Selector selector;
        private ReadoutRequestChannel[] channel;
        private boolean allStopped;
        private ReadoutRequestPayloadFactory factory;
        private ByteBuffer buf;

        RequestReceiver()
            throws IOException
        {
            selector = Selector.open();

            channel = new ReadoutRequestChannel[rdoutReqSrcChan.length];
            for (int i = 0; i < rdoutReqSrcChan.length; i++) {
                rdoutReqSinkChan[i].configureBlocking(false);
                channel[i] = new ReadoutRequestChannel(rdoutReqSrcChan[i]);
                channel[i].register(selector);
            }

            factory = new ReadoutRequestPayloadFactory();

            buf = ByteBuffer.allocate(2048);
            buf.limit(buf.capacity());
        }

        private void processStopMsg(ReadoutRequestChannel chan)
            throws IOException
        {
            chan.setStopped();

            boolean running = false;
            for (int i = 0; i < channel.length; i++) {
                if (channel[i].isRunning()) {
                    running = true;
                    break;
                }
            }

            if (!running) {
                sendHitStopSignal();
            }
        }

        private void readMessage(ReadoutRequestChannel chan)
        {
            while (true) {
                buf.position(0);
                buf.limit(4);

                int bytes;
                try {
                    bytes = chan.read(buf);
                } catch (IOException ioe) {
                    log.error("Couldn't read data", ioe);
                    break;
                }

                if (bytes == 0) {
                    break;
                } else if (bytes < 4) {
                    log.error("Only read " + bytes + " bytes");
                    continue;
                }

                final int len = buf.getInt(0);
                if (len == 4) {
                    try {
                        processStopMsg(chan);
                    } catch (IOException ioe) {
                        log.error("Couldn't process stop message", ioe);
                    }
                } else {

                    buf.position(0);
                    buf.limit(len);
                    buf.putInt(len);

                    try {
                        bytes = chan.read(buf);
                    } catch (IOException ioe) {
                        log.error("Couldn't read data", ioe);
                        break;
                    }

                    IReadoutRequest req;
                    try {
                        req = (IReadoutRequest) factory.createPayload(0, buf);
                        if (req == null) {
                            log.error("Could not create readout request" +
                                      " payload from byte buffer");
                            continue;
                        }
                        ((Payload) req).loadPayload();
                    } catch (Exception ex) {
                        log.error("Could not create readout request", ex);
                        break;
                    }

                    chan.processRequest(req);
                }
            }
        }

        public void run()
        {
            final int selectorTimeoutMsec = 100;

            while (isHitRunning) {
                int numSelected;
                try {
                    numSelected = selector.select(selectorTimeoutMsec);
                } catch (IOException ioe) {
                    log.error("Couldn't select input channels", ioe);
                    numSelected = 0;
                }

                if (numSelected > 0) {
                    Iterator iter = selector.selectedKeys().iterator();
                    while (iter.hasNext()) {
                        SelectionKey selKey = (SelectionKey) iter.next();
                        iter.remove();

                        if (selKey.isReadable()) {
                            ReadoutRequestChannel chan =
                                (ReadoutRequestChannel) selKey.attachment();
                            readMessage(chan);
                        } else {
                            log.error("Unreadable key selected");
                        }
                    }
                }
            }
        }
    }
}

class LaggedTriggerRequest
{
    private static ArrayList laggedTRList = new ArrayList();

    private GenericTriggerRequest trigReq;
    private int hitIndex;

    private LaggedTriggerRequest(GenericTriggerRequest trigReq, int hitIndex)
    {
        this.trigReq = trigReq;
        this.hitIndex = hitIndex;
    }

    static void add(GenericTriggerRequest trigReq, int hitIndex)
    {
        laggedTRList.add(new LaggedTriggerRequest(trigReq, hitIndex));
    }

    static boolean isSendable(int curIndex, int lagSize)
    {
        if (laggedTRList.size() == 0) {
            return false;
        }

        LaggedTriggerRequest tr = (LaggedTriggerRequest) laggedTRList.get(0);
        return curIndex > (tr.hitIndex + lagSize);
    }

    static GenericTriggerRequest getTriggerRequest()
    {
        if (laggedTRList.size() == 0) {
            return null;
        }

        LaggedTriggerRequest tr =
            (LaggedTriggerRequest) laggedTRList.remove(0);
        return tr.trigReq;
    }
}
